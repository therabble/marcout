
DESCRIPTION--------------------------------------

MARCout is a high-level language for defining MARC bibliographic record
exports. It's currently developed for MUSICat album records.

MARCout describes the necessary prerequisites and desired fields in
a simple declarative form. The hope is that MARCout authoring and editing
should be within the grasp of bibliographers who are not programmers.

MARCout PROCESS CHAIN

    {MARCout export definition}
        |
         -->[MARCout parser]
                |
                 -->{export data structure}
                            |
                            |
    {source record (JSON)}   -->[                       |
        |                       |MARCout record exporter|                       |
         ---------------------->|                       ]
                                    |
                                     -->{exported record}
                                            |
                                             --> [MARCout text serializer]
                                            or
                                            |
                                             --> [MARCout ISO 2709 serializer]


EXPRESSIONS
MARCout defines a simple "expression" syntax for defining exported data. 
Expressions are composed of:

    - MARCout keywords and operators: a limited set of reserved words, single
        characters, and phrases that provide simple expression semantics.

    - Literal content: fixed strings. Always enclosed in single quotes.

    - Source record extraction expressions: named JSON node syntax expressions
        found in the JSON EXTRACTED PROPERTIES block of a MARCout file.

    - Function calls: functions whose signatures are listed in the FUNCTIONS 
        block of a MARCout file.

    - Parameters: parameters whose names are listed in the KNOWN PARAMETERS
        block of a MARCout file

GEEKLY DISCLAIMER:
Programmers will be disappointed with MARCout expression semantics & syntax.
They will feel immediately frustrated because their normal modes of
thought and work are ruthlessly unsupported. So, it's important to emphasize
that MARCout EXPRESSIONS WERE NEVER INTENDED TO BE A SCRIPTING LANGUAGE.
They are only a simplistic declarative way to state common-case rules and
directives for composing MARC export content.

The keywords and operators, in particular, very deliberately leave out some
things that programmers would expect. For example:

    - Expression keywords and operators do not support IF/ELSE conditionals.

    - No grouping brackets (except for the parentheses in function calls).

    - There is no proper handling of boolean logic: no `AND`, `OR`,
        or `NOT` operators; the union of `IS FALSE` and `IS TRUE` does not
        exhaust the value space of expressions (those keywords are limited
        to values that *explicitly* indicate true or false conditions).

    - No arithmetic.

    - No date comparisons.

    - And so on.

Take heart, though, programmers: the extensibility loophole is that MARCout
permits you to define your own functions and add them to your MARCout record
exporter. NB: don't forget to add them to the MARCout export definition 
FUNCTIONS block too.

MARCout EXPRESSION SPECIFIC VALUES:

    - `PRESENT`: (for JSON node expressions and parameters.) A MARCout
        expression evaluates as `PRESENT` if it does not encounter a
        "not found" or "undefined" problem.

        Note that an expression will evaluate as `PRESENT` irrespective of
        its value. A value of None, JSON null, or an empty string, in
        particular, does not prevent, or in any way affect, evaluation as
        `PRESENT`.

    - `FALSE`: a MARCOUT expression evaluates as `FALSE` if it is `PRESENT`
        and has one of the following values: 

            - `false` (if boolean),

            - case-insensitive "no" or case-insensitive "false" (if string), 

            - 0 (if number)

        Note! the values 'F' and 'N' do NOT evaluate as `FALSE`, because 
        they could reasonably signify something else. If you have a "Y/N"
        or "T/F" enumeration in a field in your JSON, test for the
        explicit value.

    - `TRUE`: a MARCout expression evaluates as `TRUE` if it is `PRESENT`
        and has one of the following values: 

            - `true` (if boolean),

            - case-insensitive "yes" or case-insensitive "true" (if string), 

            - 1 (if number)

        Note! the values 'T' and 'Y' do NOT evaluate as `FALSE`, because 
        they could reasonably signify something else. If you have a "Y/N"
        or "T/F" enumeration in a field in your JSON, test for the
        explicit value.

    - `EMPTY`: a MARCout expression evaluates as `EMPTY` if it is `PRESENT`
        and is one of the following:

            - an empty string

            - a whitespace string

            - a collection of type `list`, `tuple`, `dict`, or `set`, with 
                length of zero.


MARCout EXPRESSION KEYWORDS AND OPERATORS:
This syntax is intended to be simple to learn and not confusing to sight-read.
It facilitates composing extracted content from the record to export with
literal values and function calls.

    - `IS`: infix operator that compares two sub-expressions for equality. 
        Equivalent to `==` in Python.

    - `IS NOT`: infix operator that compares two sub-expressions for inequality. 
        Equivalent to `!=` in Python.

    - `IS TRUE`: postfix operator that resolves to True if the preceding
        expression is a MARCout value for `TRUE`.

    - `IS FALSE`: postfix operator that resolves to True if the preceding
        expression is a MARCout value for `FALSE`.

    - `HAS VALUE`: postfix operator that resolves to True if the preceding 
        expression is PRESENT and not `EMPTY`. In other words, the expression
        has meaning over and above the ambiguous empty values.

    - `HAS NO VALUE`: postfix operator that resolves to True if the preceding
        expression is not `PRESENT`, or, if `PRESENT`, is `EMPTY`.

    - `NOTHING`: alias (non-operator) keyword for generation of an empty value.
        Depending on context, makes an empty string, or a non-value such as 
        Python `None` or JSON `null`.

    - `STARTS WITH`: operator for string values. Resolves to True if the
        preceding string starts with the subsequent string.

    - `CONTAINS`: operator for string values. Resolves to True if the
        preceding string starts with the subsequent string.

    - `+`: the concatenation operator for string values. Does NOT represent
        numeric addition, date addition, etc.





KNOWN PARAMETERS---------------------------------

    collection_namespace

    collection_label

    collection_abbr

    collection_host_url



JSON EXTRACTED PROPERTIES------------------------

    album_id = album_json['album']['id']

    main_artist_name = album_json['album']['main_artist_name']

    artist_is_group = album_json['album']['artist_is_group']

    album_title = album_json['album']['title']

    release_date = normalize_date(album_json['album']['release_date'])

    record_label = album_json['album']['record_label']

    submission_round = album_json['album']['round']

    album_tracks = album_json['album']['tracks']

    spoken_languages = album_json['album']['spoken_languages']

    genre = album_json['album']['genre']

    front_cover_art_link = album_json['album']['front_cover_art']



FUNCTIONS----------------------------------------

    biblio_name(main_artist_name)

    normalize_date(release_date)

    release_year(release_date)

    release_decade(release_date)

    render_track_duration(track_duration)

    pretty_comma_list(listexpr)

    total_play_length(album_tracks)

    compute_control_number(album_id, collection_abbr)



MARC FIELD TEMPLATES------------------------------------

FIELD: 001
    CONTENT: compute_control_number(album_id, collection_abbr)


FIELD: 003
    CONTENT: collection_label + ' MUSICat'


# example of commenting out a block of code
#FIELD: 003
#    SUBFIELD: a
#        collection_label + ' MUSICat'


FIELD: 100
# note that "EXPORT UNLESS" is a default: if the property is missing or screwed up,
# that counts as ("artist_is_group": false), so you DO export this field.
EXPORT UNLESS: artist_is_group IS TRUE     # This is the conjectural "artist_is_group" property
INDC1: 1
INDC2: blank
    SUBFIELD: a                         # subfield code on same line
        # it's OK to have a comment in between -- they get stripped out first
        biblio_name(main_artist_name)   # subfield value on VERY NEXT non-comment line


FIELD: 110
EXPORT WHEN: artist_is_group IS TRUE
INDC1: 2
INDC2: blank
    SUBFIELD: a
        main_artist_name + ' (Musical group)'


FIELD: 245
INDC1: 1
INDC2: 0
    SUBFIELD: a
        album_title
    SUBFIELD: c
        main_artist_name


FIELD: 260
INDC1: blank
INDC2: blank
    SUBFIELD: a
        '[Place of publication not indicated] :'
    SUBFIELD: b
        record_label
    SUBFIELD: c
        release_year(release_date)


FIELD: 300
INDC1: blank
INDC2: blank
    SUBFIELD: 1
        'online resource (1 audio file (' + total_play_length(album_tracks) + ')) ;'
    SUBFIELD: b
        'digital'


FIELD: 500
INDC1: blank
INDC2: blank
    SUBFIELD: a
        'MUSICat Submission Round: ' + submission_round


FIELD: 506
INDC1: blank
INDC2: blank
    SUBFIELD: a
        'Streaming available to Library patrons.'
    SUBFIELD: m
        collection_label + ' content provided by MUSICat'


FIELD: 511
INDC1: blank
INDC2: blank
    SUBFIELD: a
        'Performed by ' + main_artist_name


FIELD: 505
INDC1: 0
INDC2: 0
    FOR EACH: track in album_tracks
        EACH-SUBFIELD: t
            track::title
        EACH-SUBFIELD: g
            render_duration(track::duration)
        SORT BY: track::position
        # EACH-PREFIX:
        EACH-SUFFIX: ' --'


FIELD: 546
INDC1: blank
INDC2: blank
    SUBFIELD: a
        'Sung in ' + pretty_comma_list(spoken_languages)


FIELD: 650
INDC1: blank
INDC2: 0
    SUBFIELD: a
        genre
    SUBFIELD: y
        release_decade(release_date)


FIELD: 710
INDC1: 2
INDC2: blank
    SUBFIELD: a
        'Rabble, LLC'
    SUBFIELD: u
        'MUSICat'


# subfield 42
FIELD: 856
INDC1: 4
INDC2: 2
    SUBFIELD: z
        'Cover image'
    SUBFIELD: u
        front_cover_art_link


# subfield 40
FIELD: 856
INDC1: 4
INDC2: 0
    SUBFIELD: u
        collection_host_url + '/albums/' + album_id
    SUBFIELD: z
        'Click here to access this electronic item'





DESCRIPTION--------------------------------------

MARCout is a high-level language for defining MARC bibliographic record
exports. It's currently developed for MUSICat album records.

MARCout describes the necessary prerequisites and desired fields in
a simple declarative form. The hope is that MARCout authoring and editing
should be within the grasp of bibliographers who are not programmers.

MARCout PROCESS CHAIN

    {MARCout export definition}
        |
         -->[MARCout parser]
                |
                 -->{export data structure}
                            |
                            |
    {source record (JSON)}   -->[                       |
        |                       |MARCout record exporter|                       |
         ---------------------->|                       ]
                                    |
                                     -->{exported record}
                                            |
                                             --> [MARCout text serializer]
                                            or
                                            |
                                             --> [MARCout ISO 2709 serializer]


EXPRESSIONS
MARCout defines a simple "expression" syntax for defining exported data. 
Expressions are composed of:

    - MARCout keywords and operators: a limited set of reserved words, single
        characters, and phrases that provide simple expression semantics.

    - Literal content: fixed strings. Always enclosed in single quotes.

    - Source record extraction expressions: named JSON node syntax expressions
        found in the JSON EXTRACTED PROPERTIES block of a MARCout file.

    - Function calls: functions whose signatures are listed in the FUNCTIONS 
        block of a MARCout file.

    - Parameters: parameters whose names are listed in the KNOWN PARAMETERS
        block of a MARCout file

GEEKLY DISCLAIMER:
Programmers will be disappointed with MARCout expression semantics & syntax.
They will feel immediately frustrated because their normal modes of
thought and work are ruthlessly unsupported. So, it's important to emphasize
that MARCout EXPRESSIONS WERE NEVER INTENDED TO BE A SCRIPTING LANGUAGE.
They are only a simplistic declarative way to state common-case rules and
directives for composing MARC export content.

The keywords and operators, in particular, very deliberately leave out some
things that programmers would expect. For example:

    - Expression keywords and operators do not support IF/ELSE conditionals.

    - No grouping brackets (except for the parentheses in function calls).

    - There is no proper handling of boolean logic: no `AND`, `OR`,
        or `NOT` operators; the union of `IS FALSE` and `IS TRUE` does not
        exhaust the value space of expressions (those keywords are limited
        to values that *explicitly* indicate true or false conditions).

    - No arithmetic.

    - No date comparisons.

    - And so on.

Take heart, though, programmers: the extensibility loophole is that MARCout
permits you to define your own functions and add them to your MARCout record
exporter. NB: don't forget to add them to the MARCout export definition 
FUNCTIONS block too.

MARCout EXPRESSION SPECIFIC VALUES:

    - `PRESENT`: (for JSON node expressions and parameters.) A MARCout
        expression evaluates as `PRESENT` if it does not encounter a
        "not found" or "undefined" problem.

        Note that an expression will evaluate as `PRESENT` irrespective of
        its value. A value of None, JSON null, or an empty string, in
        particular, does not prevent, or in any way affect, evaluation as
        `PRESENT`.

    - `FALSE`: a MARCOUT expression evaluates as `FALSE` if it is `PRESENT`
        and has one of the following values: 

            - `false` (if boolean),

            - case-insensitive "no" or case-insensitive "false" (if string), 

            - 0 (if number)

        Note! the values 'F' and 'N' do NOT evaluate as `FALSE`, because 
        they could reasonably signify something else. If you have a "Y/N"
        or "T/F" enumeration in a field in your JSON, test for the
        explicit value.

    - `TRUE`: a MARCout expression evaluates as `TRUE` if it is `PRESENT`
        and has one of the following values: 

            - `true` (if boolean),

            - case-insensitive "yes" or case-insensitive "true" (if string), 

            - 1 (if number)

        Note! the values 'T' and 'Y' do NOT evaluate as `FALSE`, because 
        they could reasonably signify something else. If you have a "Y/N"
        or "T/F" enumeration in a field in your JSON, test for the
        explicit value.

    - `EMPTY`: a MARCout expression evaluates as `EMPTY` if it is `PRESENT`
        and is one of the following:

            - an empty string

            - a whitespace string

            - a collection of type `list`, `tuple`, `dict`, or `set`, with 
                length of zero.


MARCout EXPRESSION KEYWORDS AND OPERATORS:
This syntax is intended to be simple to learn and not confusing to sight-read.
It facilitates composing extracted content from the record to export with
literal values and function calls.

    - `IS`: infix operator that compares two sub-expressions for equality. 
        Equivalent to `==` in Python.

    - `IS NOT`: infix operator that compares two sub-expressions for inequality. 
        Equivalent to `!=` in Python.

    - `IS TRUE`: postfix operator that resolves to True if the preceding
        expression is a MARCout value for `TRUE`.

    - `IS FALSE`: postfix operator that resolves to True if the preceding
        expression is a MARCout value for `FALSE`.

    - `HAS VALUE`: postfix operator that resolves to True if the preceding 
        expression is PRESENT and not `EMPTY`. In other words, the expression
        has meaning over and above the ambiguous empty values.

    - `HAS NO VALUE`: postfix operator that resolves to True if the preceding
        expression is not `PRESENT`, or, if `PRESENT`, is `EMPTY`.

    - `NOTHING`: alias (non-operator) keyword for generation of an empty value.
        Depending on context, makes an empty string, or a non-value such as 
        Python `None` or JSON `null`.

    - `STARTS WITH`: operator for string values. Resolves to True if the
        preceding string starts with the subsequent string.

    - `CONTAINS`: operator for string values. Resolves to True if the
        preceding string starts with the subsequent string.

    - `+`: the concatenation operator for string values. Does NOT represent
        numeric addition, date addition, etc.





KNOWN PARAMETERS---------------------------------

    collection_namespace

    collection_label

    collection_abbr

    collection_host_url



JSON EXTRACTED PROPERTIES------------------------

    album_id = album_json['album']['id']

    main_artist_name = album_json['album']['main_artist_name']

    artist_is_group = album_json['album']['artist_is_group']

    album_title = album_json['album']['title']

    release_date = normalize_date(album_json['album']['release_date'])

    record_label = album_json['album']['record_label']

    submission_round = album_json['album']['round']

    album_tracks = album_json['album']['tracks']

    spoken_languages = album_json['album']['spoken_languages']

    genre = album_json['album']['genre']

    front_cover_art_link = album_json['album']['front_cover_art']



FUNCTIONS----------------------------------------

    biblio_name(main_artist_name)

    normalize_date(release_date)

    release_year(release_date)

    release_decade(release_date)

    render_track_duration(track_duration)

    pretty_comma_list(listexpr)

    total_play_length(album_tracks)

    compute_control_number(album_id, collection_abbr)



MARC FIELD TEMPLATES------------------------------------

FIELD: 001
    CONTENT: compute_control_number(album_id, collection_abbr)


FIELD: 003
    CONTENT: collection_label + ' MUSICat'


# example of commenting out a block of code
#FIELD: 003
#    SUBFIELD: a
#        collection_label + ' MUSICat'


FIELD: 100
# note that "EXPORT UNLESS" is a default: if the property is missing or screwed up,
# that counts as ("artist_is_group": false), so you DO export this field.
EXPORT UNLESS: artist_is_group IS TRUE     # This is the conjectural "artist_is_group" property
INDC1: 1
INDC2: blank
    SUBFIELD: a                         # subfield code on same line
        # it's OK to have a comment in between -- they get stripped out first
        biblio_name(main_artist_name)   # subfield value on VERY NEXT non-comment line


FIELD: 110
EXPORT WHEN: artist_is_group IS TRUE
INDC1: 2
INDC2: blank
    SUBFIELD: a
        main_artist_name + ' (Musical group)'


FIELD: 245
INDC1: 1
INDC2: 0
    SUBFIELD: a
        album_title
    SUBFIELD: c
        main_artist_name


FIELD: 260
INDC1: blank
INDC2: blank
    SUBFIELD: a
        '[Place of publication not indicated] :'
    SUBFIELD: b
        record_label
    SUBFIELD: c
        release_year(release_date)


FIELD: 300
INDC1: blank
INDC2: blank
    SUBFIELD: 1
        'online resource (1 audio file (' + total_play_length(album_tracks) + ')) ;'
    SUBFIELD: b
        'digital'


FIELD: 500
INDC1: blank
INDC2: blank
    SUBFIELD: a
        'MUSICat Submission Round: ' + submission_round


FIELD: 506
INDC1: blank
INDC2: blank
    SUBFIELD: a
        'Streaming available to Library patrons.'
    SUBFIELD: m
        collection_label + ' content provided by MUSICat'


FIELD: 511
INDC1: blank
INDC2: blank
    SUBFIELD: a
        'Performed by ' + main_artist_name


FIELD: 505
INDC1: 0
INDC2: 0
    FOR EACH: track in album_tracks
        EACH-SUBFIELD: t
            track::title
        EACH-SUBFIELD: g
            render_duration(track::duration)
        SORT BY: track::position
        DEMARC WITH: ' --'


FIELD: 546
INDC1: blank
INDC2: blank
    SUBFIELD: a
        'Sung in ' + pretty_comma_list(spoken_languages)


FIELD: 650
INDC1: blank
INDC2: 0
    SUBFIELD: a
        genre
    SUBFIELD: y
        release_decade(release_date)


FIELD: 710
INDC1: 2
INDC2: blank
    SUBFIELD: a
        'Rabble, LLC'
    SUBFIELD: u
        'MUSICat'


# subfield 42
FIELD: 856
INDC1: 4
INDC2: 2
    SUBFIELD: z
        'Cover image'
    SUBFIELD: u
        front_cover_art_link


# subfield 40
FIELD: 856
INDC1: 4
INDC2: 0
    SUBFIELD: u
        collection_host_url + '/albums/' + album_id
    SUBFIELD: z
        'Click here to access this electronic item'


